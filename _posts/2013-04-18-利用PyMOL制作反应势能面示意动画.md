---
 layout: post
 title: 利用PyMOL制作反应势能面示意动画
 categories: 
 - 科
 tags:
 - 3D
 - python
 mathjax: true
---

## 2013-04-18 10:43:35 发布图片

## 2013-11-14 21:18:18 增加教程

![](/pic/2013-04-18_PES_ray.gif)

利用PyMOL内置的OpenGL制作了势能面反应的示意图, 具体制作过程容后再讲.

PyMOL是基于Python的分子可视化软件, 在结构生物学中使用十分广泛. 它的主要特色是对生物大分子显示效果好, 并自带一个高效的光线追踪渲染器, 能渲染出逼真的效果. 此外, PyMOL还支持脚本, 可用于精确控制显示, 并提供了一个基本的OpenGL的接口, 以便用户进行一些简单的三维动画设计.

三维建模软件有很多, 不同的软件适用于不同的领域. 最基础的如OpenGL之类, 需要你利用最基本的图元和场景选项一点一点地构建出整个场景. POV-Ray之类则侧重于光线追踪渲染, 并集成了许多可用的模型与场景, 更高级一些. Blender之类则是更通用更专业的三维建模软件, 并非专用于分子建模与可视化. 这样看起来, PyMOL算是处于OpenGL和Blender中间, 集成了POV-Ray的部分功能, 专门用于分子可视化的. 建模时它可以实时可视化, 调试很分方便, 因此对于一些简单的应用很合适.

PyMOL中, 三维模型被称作CGO(Compiled Graphics Objects), 可在其中引用一些OpenGL基本图元. 使用方法和OpenGL很类似, 但由于调用是基于Python的, 所以比直接使用OpenGL简单一些.

下面说说上面两个动画的制作方法.

首先我们需要一个二维势能面的模型. 这个模型最好能够具有一般势能面的特点, 并且包含各类驻点, 如极大点, 极小点, 鞍点. 这就要求势能面上至少有两个极大点. 经过比较, 我发现二元函数 $F(x,y)={\sin x \over x}+{\sin y \over y}$ 满足要求. 但此函数为周期函数, 所以最好加上一个线性项去掉周期性, 并适当调整大小. 最终我用的函数是 $F(x,y)=4({\sin x \over x}+{\sin y \over y})+0.1x$.

确定了势能函数的解析式就可以创建势能曲面了. 方法是最基本的剖分, 用三角面片对整个区间进行剖分, 再将剖分所得的三角面片组合起来. 值得注意的是剖分的方向和三角面片的法向.

至于曲面上球体运动的模拟, 可利用简单的线性步长方法. 若需要更加真实的效果, 则可利用分子动力学中的Verlet积分方法进行计算.


使用方法

1. 运行代码: `run PESdemo.py`
2. 背景设为白色: `bg white`
3. 设定光线追踪: `set ray_trace_frames=1`
4. 输出png图片: `mpng PESdemo`

渲染好的图片将输出为PESdemoXXXX.png, XXXX为编号. 利用这些图片就可以制作成动画.

支持动画的图片格式目前主要两种:

* gif 最常用的, 大家也最熟悉. 各种软件支持最好, 算是通用格式. 可惜只有256色, 失真有时很严重, 特别是对光线追踪渲染过的图片.

* apng 基于png的动画图片, 效果等同于png. 可惜目前支持不广, 尚未得到png官方承认.

更具体的信息可参考下面的网文:

1. [小牛犊APNG力挫老古董MNG](http://blog.csdn.net/dj0379/article/details/7462578)
2. [APNG编辑制作工具](http://hi.baidu.com/mudyoxorikbcdmd/item/1cd7a68f1d23642a110ef309)

### 代码

<pre class="line-numbers" data-start="0"><code class="language-python"># Language: python
# ##############################################################################
# A PES Demo
# Jicun LI: Jerkwin@gmail.com
# 2013-11-14: 1.0
# ##############################################################################

import math
from pymol import cmd
from pymol.cgo import *

def Fxy(x,y):
if x==0: Fx = 4
else: Fx = 4*math.sin(x)/x+.1*x
if y==0: Fy = 4
else: Fy = 4*math.sin(y)/y
return Fx+Fy

def dFxy(x,y):
if x==0: dFx = 0
else: dFx = 4*(x*math.cos(x)-math.sin(x))/x**2+0.1
if y==0: dFy = 0
else: dFy = 4*(y*math.cos(y)-math.sin(y))/y**2
Rtmp = 1/math.sqrt(dFx*dFx+dFy*dFy+1)
return -dFx*Rtmp, -dFy*Rtmp, Rtmp

YesNorm = 0; YesTrj = 0
Xini = 4.5
Xmin = -7; Xmax = 5.5; dX = .5; Nx = int((Xmax-Xmin)/dX)
Ymin = -7; Ymax = 7;   dY = .5; Ny = int((Ymax-Ymin)/dY)

X = [ 0 for i in range(Nx) ]
Y = [ 0 for j in range(Ny) ]
Z = [ [0]*Ny for i in range(Nx) ]
Zx= [ [0]*Ny for i in range(Nx) ]
Zy= [ [0]*Ny for i in range(Nx) ]
Zz= [ [1]*Ny for i in range(Nx) ]

for i in range(Nx): X[i] = Xmin+dX*i
for j in range(Ny): Y[j] = Ymin+dY*j

for i in range(Nx):
x=X[i]
for j in range(Ny):
	y=Y[j]
	Z[i][j] = Fxy(x,y)
	if YesNorm: Zx[i][j], Zy[i][j], Zz[i][j] = dFxy(x,y)

PES = []
PES.extend( [ COLOR,  0, 0, 0 ] )
for i in range(Nx):
PES.extend( [ BEGIN, LINE_STRIP ] )
for j in range(0,Ny):
	PES.extend( [ NORMAL, Zx[i][j], Zy[i][j], Zz[i][j] ] )
	PES.extend( [ VERTEX, X[i], Y[j], Z[i][j] ] )
PES.append( END )

for j in range(Ny):
PES.extend( [ BEGIN, LINE_STRIP ] )
for i in range(Nx):
	PES.extend( [ NORMAL, Zx[i][j], Zy[i][j], Zz[i][j] ] )
	PES.extend( [ VERTEX, X[i], Y[j], Z[i][j] ] )
PES.append( END )

PES.extend( [ COLOR, .19, .6, .83 ] )
for j in range(Ny-1):
PES.extend( [ BEGIN, TRIANGLE_STRIP ] )
for i in range(Nx):
	PES.extend( [ NORMAL, Zx[i][j+1], Zy[i][j+1], Zz[i][j+1] ] )
	PES.extend( [ VERTEX, X[i], Y[j+1], Z[i][j+1] ] )
	PES.extend( [ NORMAL, Zx[i][j], Zy[i][j], Zz[i][j] ] )
	PES.extend( [ VERTEX, X[i], Y[j],   Z[i][j] ] )
PES.append( END )

PES.extend( [ LINEWIDTH, 5 ] )
PES.extend( [ BEGIN, LINE_STRIP ] )
PES.extend( [ COLOR, 1., 0., .0 ] )
x = -Xini; y = -Xini
while y<=Xini:
z = Fxy(x,y)
dFx, dFy, dFz = dFxy(x,y)
PES.extend( [ NORMAL, dFx, dFy, dFz ] )
PES.extend( [ VERTEX, x, y, z ] )
y = y+0.1
PES.append( END )

PES.extend( [ BEGIN, LINE_STRIP] )
PES.extend( [ COLOR, 0, 1., .0 ] )
x = -Xini; y = -Xini
while x<=Xini:
z = Fxy(x,y)
dFx, dFy, dFz = dFxy(x,y)
PES.extend( [ NORMAL, dFx, dFy, dFz ] )
PES.extend( [ VERTEX, x, y, z ] )
x = x+0.1
PES.append( END )

x = -Xini; y = -Xini; z = Fxy(x,y)
PES.extend ( [ COLOR, 1, 1, 0 ] )
PES.extend ( [ SPHERE, x, y, z, .2 ] )
x = -Xini; y = Xini; z = Fxy(x,y)
PES.extend ( [ COLOR, 1, 0, 0 ] )
PES.extend ( [ SPHERE, x, y, z, .2 ] )
x = Xini; y = -Xini; z = Fxy(x,y)
PES.extend ( [ COLOR, 0, 1, 0 ] )
PES.extend ( [ SPHERE, x, y, z, .2 ] )

cmd.load_cgo(PES, 'PES')

Rsph = 0.5
if not YesTrj:
x = -Xini
for Ifrm in range(30):
	y = -Xini+Ifrm*0.3; z = Fxy(x,y)
	dFx, dFy, dFz = dFxy(x,y)
	SYS = [ COLOR, 1, 1-Ifrm/30., 0 ]
	SYS.extend( [ SPHERE, x+Rsph*dFx, y+Rsph*dFy, z+Rsph*dFz, Rsph ] )
	cmd.load_cgo(SYS, 'SYS', Ifrm)

y = -Xini
for Ifrm in range(30):
	x = -Xini+Ifrm*0.3; z = Fxy(x,y)
	dFx, dFy, dFz = dFxy(x,y)
	SYS = [ COLOR, 1-Ifrm/30., 1, 0 ]
	SYS.extend( [ SPHERE, x+Rsph*dFx, y+Rsph*dFy, z+Rsph*dFz, Rsph ] )
	cmd.load_cgo(SYS, 'SYS', Ifrm+30)
else:
x = -Xini; y=-Xini
vx = 0.5; vy = 0.42; dt = 0.05; E0 = 0.5*(vx*vx+vy*vy)+Fxy(x,y)
dFx0, dFy0, dFz0 = dFxy(x,y)
for Ifrm in range(550):
	SYS = [ COLOR, 1, 1, 1 ]
	x = x + (vx + 0.5*dFx0*dt)*dt;
	y = y + (vy + 0.5*dFy0*dt)*dt;
	z = Fxy(x,y)
	dFx, dFy, dFz = dFxy(x,y)
	SYS.extend( [ SPHERE, x+Rsph*dFx, y+Rsph*dFy, z+Rsph*dFz, Rsph ] )
	cmd.load_cgo(SYS, 'SYS', Ifrm)

	vx = vx+0.5*(dFx0+dFx)*dt
	vy = vy+0.5*(dFy0+dFy)*dt
	E = 0.5*(vx*vx+vy*vy)
	Rtmp = math.sqrt(2.*abs(E0-z)/(vx*vx+vy*vy))
	vx = vx*Rtmp; vy = vy*Rtmp
	dFx0, dFy0 = dFx, dFy

cmd.reset()
cmd.zoom('PES', 1.0)
cmd.clip('far', -10.0)
cmd.turn('z', 30)
cmd.turn('x', -60)
cmd.mplay()
</code></pre>
